\chapter{Descrizione classi}
\section{Modalspace}

Inizialmente ModalSpace \`e stata concepita per essere una classe base, dalla quale ereditasse ogni possibile scelta delle condizioni di bordo sulla parete del vaso. Facendo un rapido conto ci si accorge che comprendendo le condizioni di Dirichlet, Neumann e Robin su una sezione rettangolare arriviamo a 81 possibili combinazioni. Una grande quanti\`a di codice da scrivere, che comprende casistiche molto simili fra loro se non identiche. Questo \`e stato il primo motivo che ci ha portato a scorporare il trattamento delle condizioni di bordo dalla classe ModalSpace per poi includerlo in modo ottimale in Basis1DAbstract. Un secondo punto a favore di questa scelta riguarda la valutazione e la lettura delle basi modali. \`E chiaro che le basi modali sono contenute in ModalSpace, tuttavia ogni figlia avrebbe avuto un tipo di base differente e accedervi tramite la classe base ogni qual volta fosse necessario, non risultava essere efficiente. Infine abbiamo ottenuto maggiore generalit\`a, ModalSpace \`e pronta ad utilizzare nuovi metodi in grado di generare una corretta base modale, infatti la classe possiede esclusivamente le valutazioni delle basi modali su un'opportuna griglia e i generatori di basi.

\subsection{I membri}
ModalSpace conosce la geometria della sezione (Ly, Lz) e sicuramente deve conoscere il grado di precisione desiderato dall'utente, ovvero il numero di modi da utilizzare (mtot). 
Un altro punto fondamentale del costruttore generico \`e senz'altro la regola di quadratura da utilizzare sulla slice. Si noti che le basi utilizzate necessitano regole di quadratura di alto ordine e il grado di esattezza \`e strettamente legato al numero di modi. Questo legame \`e evidente se si pensa che maggiore \`e il modo, maggiore sar\`a la frequenza della base modale e di conseguenza si avr\`a bisogno di una fitta successione di nodi di quadratura. Su una sezione quadrata una buona approssimazione dei nodi necessari su ciascun lato \`e $\sqrt{mtot}$. Il risultato non \`e valido nel caso di sezioni molto asimmetriche, infatti rettangoli molto allungati in una direzione avranno bisogno di pi\`u nodi lungo la direzione maggiore e meno sull'altra. Come esempio si osservi la seguente tabella dove sono riportati i check dei valori di normalit\`a di una base, fissata la regola di quadratura al variare della dimensione $L_y$.
\begin{equation}
\textcolor{red}{TABELLA}
\end{equation}
Una volta creato l'oggetto \texttt{ModalSpace} bisogna eseguire alcuni set importanti. Per prima cosa dobbiamo impostare i generatori di base lungo le direzioni trasversali. Nel caso di basi educate questa operazione viene eseguita assieme all'imposizione delle condizioni di parete tramite i metodi pubblici:
\begin{itemize}
\item \texttt{void AddSliceBCY(const string left, const string right, const Real mu = 1, const Real Chi =1)};
\item \texttt{void AddSliceBCZ(const string left, const string right, const Real mu = 1, const Real Chi =1)}
\end{itemize}

\begin{lstlisting}[style = general]
void ModalSpace::
AddSliceBCY (const string& left, const string& right, const Real& mu, const Real& chi)
{
	M_genbasisY = Basis1DFactory::istance().createObject(left+right;)
	M_genbasisY->setL(M_Ly);
	M_genbasisY->setMu(M_mu);
	M_genbasisY->setChi(chi)
	
	return;
}
\end{lstlisting}
 Nel caso di future generalizzazioni o aggiunte di nuove basi sar\`a in questo punto che occorrer\`a procedere.
\textcolor{red}{Qua aprire il discorso della factory?}. In pratica si occupano di assegnare il giusto generatore ai membri \texttt{M\_genbasisY} e \texttt{M\_genbasisZ}. Nel nostro codice questi membri sono dei puntatori ad oggetti di tipo \texttt{Basis1DAbstract}, vedremo nel dettaglio la loro implementazione nella prossima sezione. 
Infine si conlude il seting della classe ModalSpace tramite la funzione membro pubblica EvaluateBasis(), che chiama le funzioni che si occupano di riempire le strutture dati.

\begin{lstlisting}[style = general]
boost::shared_ptr<ModalSpace> MB (new ModalSpace(Ly,Lz,mtot,quadY,quadZ));
MB ->AddSliceBCY("dir","dir");
MB ->AddSliceBCZ("rob","rob",1.,3.);
MB ->EvaluateBasis();
\end{lstlisting}

\subsubsection{Strutture dati}
Diamo un breve descrizione delle strutture dati possedute dalla classe ModalSpace. Per prima cosa per\`o, occupiamoci aspetto fondamentale: le basi modali sono determinate sull'intervallo di riferimento. Per non incorrere in errori fra dominio reale e riferimento,  utilizzeremo la seguente notazione:
\begin{equation}
\label{eq: notazione}
\begin{array}{l l l}
\hat{\varphi}_j(\hat{y},\hat{z}) = \hat{\eta}_j(\hat{y}) \hat{\xi}_j(\hat{z}) & \hat{y} \in [0,1] & \hat{z} \in [0,1] 
\\
\\
\int_0^1 \hat{\eta}^2_j\,d\hat{y} = 1 & \int_0^1 \hat{\xi}^2_j\,d\hat{z} = 1
\end{array}
\end{equation}
Dove $\hat{\varphi_j}$ \`e la base modale ortonormale sul dominio di riferimento, risultato del prodotto delle basi ottenute tramite i generatori di basi.
Vediamo ora come gestire il passaggio dalle basi definite sul riferimento a quelle invece sul dominio reale. L'ortogonalit\`a si conserva facilmente, ma lo stesso discorso non vale per la normalizzazione. Verifichiamo che un semplice cambio di coordinate non conserva la normalizzazione:

\begin{equation}
\label{eq: trasformazione}
\begin{array}{l l }
\int_0^{L_y}\int_0^{L_z} \varphi_j(y,z)^2 \,dydz 
\\
\\
= \int_0^{L_y} \eta_j(y)^2 \,dy\int_0^{L_z} \xi_j(z)^2 \,dz 
\\
\\
= \int_0^{1} \eta_j(L_y\hat{y})^2 L_y\,d\hat{y} \int_0^{1} \xi_j(L_z\hat{z})^2 L_z\,d\hat{z} 
\\
\\
 = L_yL_z\int_0^{1} \hat{\eta}_j(\hat{y})^2 \,d\hat{y} \int_0^{1} \hat{\xi}_j(\hat{z})^2 \,d\hat{z} & \neq  1  
\end{array}
\end{equation}

Da questi semplici passaggi deduciamo che per essere mantenere la normalizzazione, la base che stiamo cercando avr\`a la seguente forma:
\begin{equation}
\label{eq: base sul dominio corrente}
\varphi_j(y,z) = (L_yL_z)^{-\frac{1}{2}}\hat{\eta}_j(yL_y^{-1})\hat{\xi}_j(zL_z^{-1})
\end{equation}
In conclusione, nei conti che verranno proposti si utilizzer\`a sempre questa forma della base modale.

Procediamo con la descrizione delle strutture dati:

\begin{itemize}

\item \texttt{EigenContainer M\_eigenvalues}, contiene le sottofrequenze e gli indici corrispondenti, viene prodotta in fase di setting dello spazio modale tramite la funzione membro \texttt{EigensProvider()}, chiamata da \texttt{EvaluateBasis()}. Il tipo \`e un \texttt{vector$<$EigenMap$>$} dove:
 
\begin{lstlisting}[style = general]
struct EigenMap
{
	Real wp;	//subfrequency y
	Real wq;	//subfrequency z
	UInt p;
	UInt q;
	
	static EigenMap make_eigenmap(const Real& _wp,const Real& _wq,const UInt& _p,const UInt& _q)
	{
		EigenMap a;
		a.wp = _wp;
		a.wq = _wq;
		a.p = _p;
		a.q = _q;
		return a;	
	}
};
\end{lstlisting}
L'ordinamento gerarchico degli autovalori e la corrispondenza delle sottofrequenze con i sottoindici \`e fondamentale, approfondiremo in seguito il metodo \texttt{EigensProvider()}.

\item \textbf{MBMatrix\_type M\_phiy}, \`e un \texttt{vector$<$vector$<$Real$>$ $>$} che raccoglie la valutazione di $\hat{\eta}_j(\hat{y})$ $\forall j$ e per ogni nodo di quadratura lungo $\hat{y}\in[0,1]$.

\item \textbf{MBMatrix\_type M\_phiz}, \`e un \texttt{vector$<$vector$<$Real$>$ $>$} che raccoglie la valutazione di $\hat{\xi}_j(\hat{y})$ $\forall j$ e per ogni nodo di quadratura lungo $\hat{z}\in[0,1]$.

\item \textbf{MBMatrix\_type M\_dphiy}, \`e un \texttt{vector$<$vector$<$Real$>$ $>$} che raccoglie la valutazione di $\frac{\partial\hat{\eta}_j}{\partial 	\hat{y}}$ $\forall j$ e per ogni nodo di quadratura lungo $\hat{y}\in[0,1]$.

\item \textbf{MBMatrix\_type M\_dphiz}, \`e un \texttt{vector$<$vector$<$Real$>$ $>$} che raccoglie la valutazione di $\frac{\partial\hat{\xi}_j}{\partial 	\hat{z}}$ $\forall j$ e per ogni nodo di quadratura lungo $\hat{z}\in[0,1]$.

\end{itemize}


\subsubsection{Metodi di calcolo}
Approfondiamo ora i metodi che si occupano di calcolare i coefficienti della matrice di sistema.

\begin{itemize}
\item \texttt{Real Compute\_PhiPhi(const UInt\& j, const UInt\& k)}

 $\int_{\gamma_x}\varphi_j(y,z)\varphi_k(y,x) \,dydz$

\item \texttt{Real Compute\_DyPhiPhi(const UInt\& j,const UInt\& k)} 

$\int_{\gamma_x} \partial_y \varphi_j(y,z)\varphi_k(y,x) \,dydz$

\item \texttt{Real Compute\_DzPhiPhi(const UInt\& j,const UInt\& k)} 

$\int_{\gamma_x} \partial_z \varphi_j(y,z)\varphi_k(y,x) \,dydz$

\item \texttt{Real Compute\_DyPhiDyPhi(const UInt\& j,const UInt\& k)} 

$\int_{\gamma_x} \partial_y \varphi_j(y,z)\partial_y\varphi_k(y,x) \,dydz$

\item \texttt{Real Compute\_DzPhiDzPhi(const UInt\& j,const UInt\& k)} 

$\int_{\gamma_x} \partial_z \varphi_j(y,z)\partial_z\varphi_k(y,x) \,dydz$

\item \texttt{Real Compute\_Phi(const UInt\& k)} 

$\int_{\gamma_x} \varphi_k(y,x) \,dydz$

\item \texttt{vector$<$Real$>$ FourierCoefficients (const function\_Type\& g) const},

data una funzione indipendente da $x$ questo metodo restituisce i coefficienti di Fourier (in numero pari ad \texttt{M\_mtot}) rispetto alla base modale scelta.

\item \texttt{Real Coeff\_fk (	const Real\& x,const function\_Type\& f,const UInt\& k ) const},

restituisce il $k$-esimo coefficiente di Fourier di una generica funzione 3D valutato nel punto $x$, rispetto alla base modale.
\end{itemize}

Date le premesse risulta ora semplice risolvere gli integrali scritti qui sopra, vediamo ad esempio che aspetto ha \texttt{Compute\_PhiPhi()}:


\begin{lstlisting}[style = general]
Real ModalSpace::
Compute_PhiPhi(const UInt& j, const UInt& k) const
{
	Real coeff_y = 0.0;
	Real coeff_z = 0.0;
	UInt p_j = M_eigenvalues[j].p-1;
	UInt p_k = M_eigenvalues[k].p-1;
	UInt q_j = M_eigenvalues[j].q-1;
	UInt q_k = M_eigenvalues[k].q-1;
	
	Real normy = 1.0 / sqrt(M_Ly);
	Real normz = 1.0 / sqrt(M_Lz);
	
	for(UInt n = 0; n < M_quadruleY->nbQuadPt();++n)
	{
		coeff_y +=	M_phiy[p_j][n] * normy *	
							M_phiy[p_k][n] * normy *
							M_Ly * M_quadruleY->weight(n);
	}
	
		for(UInt n = 0; n < M_quadruleZ->nbQuadPt();++n)
	{
		coeff_z +=	M_phiz[q_j][n] * normz *	
							M_phiz[q_k][n] * normz *
							M_Lz * M_quadruleZ->weight(n);
	}
	
	return coeff_y*coeff_z;
}
\end{lstlisting}
 
 Gli ultimi due metodi citati sono indispendabili ed il loro impiego sar\`a noto una volta che tratteremo la classe \texttt{HiModAssembler}.
 
 \section{Basis1dAbstract}

Le Educated Bases (E.B.) sono una scelta possibile da adottare nella risoluzione di un problema ADR con tecniche di riduzione gerarchica. Il concetto base si fonda sul teorema (citazione di Salsa) e sullipotesi di separabilit\`a delle variabili. Le E.B. vengono costruite "ad hoc" sulle condizioni di vaso del problema in oggetto. L'algoritmo che permette la generazione di queste basi \`e riassunto qui di seguito:

\begin{itemize}
\item[\textbf{1.}] \textbf{Costruzione di un problema ausiliario} che rispecchi la natura delle condizioni alle pareti del problema originale (devono essere omogenee) e passaggio ai relativi problemi agli autovalori.
\mybox{
Nel caso si abbiano condizioni di robin uguali sull'intera parete del vaso, dovremo considerare il seguente problema ausiliario:
\begin{equation}
\label{eq: problema RRRR}
\begin{cases}
-\Delta u(y,z)= 0 & \text{in $\gamma_x$}\\
\mu \nabla u(y,z) \cdot \vect{n}_{\gamma_x} +\chi u(y,z)=0 & \text{su $\Gamma_{vaso}$} \\
\end{cases}
\end{equation}
Si passi ora al problema agli autovalori associato al precedente sistema e ipotizzando la separazione di variabili per $u(y,z)=\varphi(y)\vartheta(z)$, si arrivano facilmente ad ottenere i seguenti sottoproblemi agli autovalori:
\begin{equation}
\label{eq: problema RR1}
\begin{cases}
-\varphi(y)'' = K_y\varphi(y) & \\
\mu \varphi(y)' +\chi \varphi(y) = 0 & \text{per $y=L_y$} \\
-\mu \varphi(y)'+\chi \varphi(y)=0 & \text{per $y=0$} \\
\end{cases}
\end{equation}
\begin{equation}
\label{eq: problema RR2}
\begin{cases}
-\vartheta(z)'' = K_z\vartheta(z) & \\
\mu \vartheta(z)' +\chi \vartheta(z) = 0 & \text{per $z=L_z$} \\
-\mu \vartheta(z)'+\chi \vartheta(z)=0 & \text{per $z=0$} \\
\end{cases}
\end{equation}
}{Esempio - RRRR}

\item[\textbf{2.}] \textbf{Identificazione del tipo di soluzione} dei problemi agli autovalori associati.

\mybox{
Per i sottoproblemi ottenuti i generi di soluzione sono i seguenti:
\begin{equation}
\label{eq: 1sottoproblema}
\begin{array}{c}
\varphi (y)=Asin(\sqrt{K_y}y)+Bcos(\sqrt{K_y}y) \\ \\
\vartheta (z)=Asin(\sqrt{K_z}z)+Bcos(\sqrt{K_z}z)
\end{array}
\end{equation}

}{Esempio - RRRR}

\item[\textbf{3.}] \textbf{Ricerca degli autovalori di un sottoproblema} tramite risoluzione dell'equazione non lineare associata ad esso, ottenuta risolvendo le condizioni di bordo.
\mybox{
Nel caso trattato in esempio le equazioni che si ottengono sono le seguenti ($x = \sqrt{K_y}$ e $w= \sqrt{K_z}$):
\begin{equation}
\label{eq: funzione autovalori}
\begin{array}{c}
f(x)= 2\mu x + tan(L_y x)\left(\chi - \frac{\mu ^2 x^2 }{\chi} \right) \\ \\
f(w)= 2\mu w + tan(L_z w)\left(\chi - \frac{\mu ^2 w^2 }{\chi} \right)
\end{array}
\end{equation}
}{Esempio - RRRR}
\end{itemize}

Come presentato in breve nel capitolo (Nozioni base), HiMod si basa sulla riduzione dei gradi di libert\'a del sistema discreto, questo risultato si ottiene ordinando le basi scelte in maniera gerarchica ed utilizzando quelle legate alle frequenze pi\'u basse. Dunque il primo passo \'e capire, dato un numero di modi massimo che si vuole dedicare per la componente trasversale, qual'\'e il set di basi modali da utilizzare.
\mybox{
Nel caso di condizioni al bordo di Dirichlet il problema si semplifica. Infatti non occorre adottare l'algoritmo mostrato precedentemente, gli autovalori che si ottengono sono noti a priori e sono della forma:
\begin{equation}
\label{eq: problema agli autovalori dirichlet}
\begin{array}{c l}
K_y = \big( \frac{\pi p}{L_y}\big)^2 & p = 1, ... ,m_y\\
K_z = \big( \frac{\pi q}{L_z}\big)^2 & q = 1, ... ,m_z\\
\end{array}
\end{equation}
Dunque \'e nota la relazione $\lambda(K_y,K_z)$ a priori e risulta molto semplice ordinare in modo crescente gli autovalori definendo quindi $m_y$ e $m_z$.
}{Osservazione}


\textcolor{red}{Possiamo discutere velocemente l'albero delle scelte (che poi sarebbe la funzione EigensProvider), che in realt\'a sar\'a utilizzato tale e quale per il caso generale delle educated basis, infatti se adesso il passaggio \'e semplicemente p = p +1, dopo il passaggio sar\'a p = Next().
La ricerca degli autovalori rallenter\'a parecchio dato che si dovr\'a risolvere un problema non lineare ogni volta che si vuole aggiornare un nodo.}

Esponiamo quindi lo pseudocodice che, dato il numero di modi da utilizzare, determina l'elenco delle frequenze e sotto frequenze:


\begin{lstlisting}
//Dichiarazione set di ritorno
M_Eigenvalues;
//Suggerisco di farlo un pair di pair visto che non possiamo fare la tupla, la prima pair sono i sotto autovalori, la seconda pair sono le coordinate (ovver p e q)

//Dichiarazione set degli scarti
scarti;

//Inserimento delle prime sottofrequenze e prima coordinata (1,1)
KzOld = M_EducatedBasisy->Next();
kyOld = M_educated->BasiszNext();
M_eigenvalues.insert(make_pair(KyOld,KzOld) );

//Inizializzazione set degli scarti
scarti.insert(make_pair(M_EducatedBasisy->Next(),KzOld));
scarti.insert(make_pair(KyOld,M_EducatedBasisz->Next()));

//Ciclo sul numero di modi scelto
for(UInt i=1;i\M_mtot;++i)
{
	//Prendo il primo elemento del vettore degli scarti, che sono ordinati per lambda=Ky+Kz dal più piccolo al più grande e lo inserisco nel set di uscita
	M_eigenvalues.insert(scarti.begin());

//Inoltre registro le coordinate del nodo preso e i valori dei sottoautovalori
i = prima coordinata;
j = seconda coordinata;
KzOld =  
KyOld =

//Mi occupo ora di branchare in maniera corretta e senza ricalcolare autovalori che già conosco
	if(!Check_presence(i+1,j))
		scarti.insert(Check_eigen(1,i+1),KzOld);

	if(!Check_presence(i,j+1))		
		scarti.insert(KyOld,Check_eigen(2,j+1));
}
\end{lstlisting}

\section{HiModAssembler}
 
 Sono momentaneamente separate ma \'e chiaro che devono appartenere alla stessa classe, ovvero a quella che sintetizzer\'a insieme Modalspace e FESpace 1D (ovvero quello costruito sulla fibra di supporto).
 
 \textcolor{red}{HiModView e HiModAssembler devono continuamente lavorare con gli elementi di Modalspace e FESpace 1D non sarebbe il caso di instaurare un legame pi\'u intimo?Magari specificando l'amicizia di HiMod con Modalspace e FESpace?Troppo incasinato?Si velocizza il tutto (non occorre infatti passare dai noiosi getters)?}
 
Gli unici membri di HiModAssembler e HiModView sono fespace e modalbasis (in HiModAssembler c'\'e anche etfespace ma direi che dobbiamo toglierlo e non farlo creare nel main, quella \'e sicuramente una questione interna di come abbiamo voluto implementare il calcolo dei coefficienti della matrice, inoltre aumentiamo in leggibilit\'a).

Ecco le uilit\'a di HiModAssembler:
\begin{itemize}
\item AddADRProblem
\item interpolate
\item Addrhs (costante e functionType)
\item Addrhsfunctor
\item AddDirichletBCIn (Momentanemente via penalizzazione)
\end{itemize}

Ecco invece le utilit\'a di HiModView:
\begin{itemize}
\item funCoeff3D (genera i valori nodali su una griglia partendo dal vettore soluzione o da una funzione)
\item normL2 (dato il vettore che sputa fuori funCoeff3D ne fa la normaL2)
\item ConvergeFile (crea un file di output gestibile tramite getpot, utilizzo limitato al testconvergence)
\end{itemize}




