\chapter{Descrizione classi}
\section{Modalspace}

Inizialmente ModalSpace \`e stata concepita per essere una classe base, dalla quale ereditasse ogni possibile scelta delle condizioni di bordo sulla parete del vaso. Facendo un rapido conto ci si accorge che comprendendo le condizioni di Dirichlet, Neumann e Robin su una sezione rettangolare arriviamo a 81 possibili combinazioni. Una grande quanti\`a di codice da scrivere, che comprende casistiche molto simili fra loro se non identiche. Questo \`e stato il primo motivo che ci ha portato a scorporare il trattamento delle condizioni di bordo dalla classe ModalSpace per poi includerlo in modo ottimale in Basis1DAbstract. Un secondo punto a favore di questa scelta riguarda la valutazione e la lettura delle basi modali. \`E chiaro che le basi modali sono contenute in ModalSpace, tuttavia ogni figlia avrebbe avuto un tipo di base differente e accedervi tramite la classe base ogni qual volta fosse necessario, non risultava essere efficiente. Infine abbiamo ottenuto maggiore generalit\`a, ModalSpace \`e pronta ad utilizzare nuovi metodi in grado di generare una corretta base modale, infatti la classe possiede esclusivamente le valutazioni delle basi modali su un'opportuna griglia e i generatori di basi.

\subsection{I membri}
ModalSpace conosce la geometria della sezione (Ly, Lz) e sicuramente deve conoscere il grado di precisione desiderato dall'utente, ovvero il numero di modi da utilizzare (mtot). 
Un altro punto fondamentale del costruttore generico \`e senz'altro la regola di quadratura da utilizzare sulla slice. Si noti che le basi utilizzate necessitano regole di quadratura di alto ordine e il grado di esattezza \`e strettamente legato al numero di modi. Questo legame \`e evidente se si pensa che maggiore \`e il modo, maggiore sar\`a la frequenza della base modale e di conseguenza si avr\`a bisogno di una fitta successione di nodi di quadratura. Su una sezione quadrata una buona approssimazione dei nodi necessari su ciascun lato \`e $\sqrt{mtot}$. Il risultato non \`e valido nel caso di sezioni molto asimmetriche, infatti rettangoli molto allungati in una direzione avranno bisogno di pi\`u nodi lungo la direzione maggiore e meno sull'altra (si porti qui ad esempio i conti che abbiamo fatto sulle basi, magari una piccola tabellina con gli errori). In definitiva non parliamo della regola di quadratura, ma piuttosto permettiamo all'utente di scegliere le regole di quadratura da adottare lungo i lati, sar\`a compito suo scegliere un grado di esattezza adeguato per il caso in oggetto.

Nel caso di basi educate per procedere al passo successivo occorrono le condizioni sulla parete del vaso, tuttavia questa operazione \`e stata scorporta dal costruttore al fine di garantire una certa generalit\`a e seguendo l'ottica della separazione di variabili sono state create due funzioni pubbliche dedicate ad aggiungere le condizioni di bordo:
\begin{itemize}
\item AddSliceBCY(const string left, const string right, const Real mu = 1, const Real Chi =1);
\item AddSliceBCZ(const string left, const string right, const Real mu = 1, const Real Chi =1)
\end{itemize}
Queste  funzioni definiscono il generatore di basi, che nel caso di basi educate \`e strettamente legato alla condizione di parete. Nel caso di future generalizzazioni o aggiunte di nuove basi sar\`a in questo punto che occorrer\`a procedere.
\textcolor{red}{Qua aprire il discorso della factory?}.
Infine si conlude il seting della classe ModalSpace tramite la funzione membro pubblica EvaluateBasis(), che chiama le funzioni che si occupano di riempire le cinque strutture dati utili ai fini dei conti.

\begin{lstlisting}[style = general]
boost::shared_ptr<ModalSpace> MB (new ModalSpace(Ly,Lz,mtot,quadY,quadZ));
MB ->AddSliceBCY("dir","dir");
MB ->AddSliceBCZ("rob","rob",1.,3.);
MB ->EvaluateBasis();
\end{lstlisting}

\subsubsection{Strutture dati}
Diamo un breve descrizione delle strutture dati possedute dalla classe ModalSpace:
\begin{itemize}

\item \texttt{EigenContainer M\_eigenvalues}, contiene le sottofrequenze e gli indici corrispondenti, viene prodotta in fase di setting dello spazio modale tramite la funzione membro \texttt{EigensProvider()}, chiamata da \texttt{EvaluateBasis()}. Il tipo \`e un \texttt{vector$<$EigenMap$>$} dove:
 
\begin{lstlisting}[style = general]
struct EigenMap
{
	Real wp;	//subfrequency y
	Real wq;	//subfrequency z
	UInt p;
	UInt q;
	
	static EigenMap make_eigenmap(const Real& _wp,const Real& _wq,const UInt& _p,const UInt& _q)
	{
		EigenMap a;
		a.wp = _wp;
		a.wq = _wq;
		a.p = _p;
		a.q = _q;
		return a;	
	}
};
\end{lstlisting}
L'ordinamento gerarchico degli autovalori e la corrispondenza delle sottofrequenze con i sottoindici \`e fondamentale, approfondiremo in seguito il metodo \texttt{EigensProvider()}.

\item \textbf{MBMatrix\_type M\_phiy}, valutazione delle basi modali lungo la direzione Y sui nodi di quadratura, dimensioni della matrice $p_{max}\times nquadY$;

\item \textbf{MBMatrix\_type M\_phiz}, valutazione delle basi modali lungo la direzione Z sui nodi di quadratura,dimensioni della matrice $q_{max}\times nquadZ$;

\item \textbf{MBMatrix\_type M\_dphiy}, valutazione delle derivate delle basi modali lungo la direzione Y sui nodi di quadratura;

\item \textbf{MBMatrix\_type M\_dphiz}, valutazione delle derivate delle basi modali lungo la direzione Z sui nodi di quadratura;

\end{itemize}

\subsubsection{Metodi di calcolo}
Approfondiamo ora i metodi che si occupano di calcolare i coefficienti della matrice di sistema.

\begin{itemize}
\item \texttt{Real ComputePhiPhi(const UInt\& j, const UInt\& k)}

 $\int_{\gamma_x}\varphi_j(y,z)\varphi_k(y,x) \,dydz$

\item \texttt{Real ComputeDyPhiPhi(const UInt\& j,const UInt\& k)} 

$\int_{\gamma_x} \partial_y \varphi_j(y,z)\varphi_k(y,x) \,dydz$

\item \texttt{Real ComputeDzPhiPhi(const UInt\& j,const UInt\& k)} 

$\int_{\gamma_x} \partial_z \varphi_j(y,z)\varphi_k(y,x) \,dydz$

\item \texttt{Real ComputeDyPhiDyPhi(const UInt\& j,const UInt\& k)} 

$\int_{\gamma_x} \partial_y \varphi_j(y,z)\partial_y\varphi_k(y,x) \,dydz$

\item \texttt{Real ComputeDzPhiDzPhi(const UInt\& j,const UInt\& k)} 

$\int_{\gamma_x} \partial_z \varphi_j(y,z)\partial_z\varphi_k(y,x) \,dydz$

\item \texttt{Real ComputePhi(const UInt\& k)} 

$\int_{\gamma_x} \varphi_k(y,x) \,dydz$

\item \texttt{Real Coeff\_fk (	const Real\& x,const function\_Type\& f,const UInt\& k ) const}

\item \texttt{vector$<$Real$>$ FourierCoefficients (const function\_Type\& g) const}
\end{itemize}




Modalspace \'e una classe base da cui derivano le figlie di modalspace che nascono dal momento che tipo di condizioni al bordo di parete vengono scelte.

Perch\'e si \'e scelto questo tipo di eredit\'a? Gli autovalori generati e le rispettive basi sono propriet\'a esclusiva del tipo di p roblema ai limiti che si intende istanziare. Dunque le classi figlie si preoccupano di calcolare l'appropriata successione di autovalori e inoltre registrano i valori nodali delle funzioni di base sulla griglia di quadratura scelta. I dati vengono raccolti nei membri:

\begin{itemize}
\item Eigenvalues
\item Mphi
\item Mdphi
\end{itemize}

Fissandoci sulla slice di riferimento $[0,1]\times[0,1]$, si osserva che l'unico parametro che occorre ad una figlia per generare i materiale elencato precedentemente è la specifica delle condizioni di bordo \textcolor{red}{anche mtot!!}.

\textcolor{red}{Mi sta venendo un dubbio, il discorso della factory mi aveva intrigato, tuttavia mi stavo chiedendo, ma noi cosa registriamo di preciso?Un oggetto modalspace DDDD a cui per\'o vanno specificati mtot, gli autovalori e i valori delle basi?Dovrei registrare modalspaceDDDD per ogni possibile valore di mtot!!!Forse mi sfugge qualcosa....}


Modalspace raccoglie gli elementi e le operazioni comuni a tutti i suoi figli tra questi vi sono sicuramente:
\begin{itemize}
\item Dimensioni della slice
\item Numero modi utilizzato
\item Regola di quadratura
\item Calcolo coefficienti Fourier g(y,z) - vettore [g1 g2 ...]
\item Calcolo del coefficiente Fuourier di g(x,y,z) - reale (g(x))
\end{itemize}

\textcolor{red}{In realt\'a Eigenvalues appartiene ancora a Modalspace sar\'a il caso di sposatarlo?Fare attenzione a findmyzmax() che è definito in Modalspace.cpp, lo teniamo perch\'e le funzioni comuni fanno usa di tale membro?Dovremmo costruire il getter nelle classi figlie secondo me sarebbe pi\'u coerente}

Stabiliti infatti i valori nodali delle funzioni di base e delle loro derivate tutte le basi modali istruite possono essere trattate alla stessa maniera. Sono comuni infatti i seguenti metodi (con j si intende l'indice legato alla soluzione e con k quello legato alla funzione test):
\begin{itemize}
\item ComputePhiPhi $\int_{\gamma_x}\varphi_j(y,z)\varphi_k(y,x) \,dydz$
\item ComputeDyPhiPhi $\int_{\gamma_x} \partial_y \varphi_j(y,z)\varphi_k(y,x) \,dydz$
\item ComputeDzPhiPhi
$\int_{\gamma_x} \partial_z \varphi_j(y,z)\varphi_k(y,x) \,dydz$
\item ComputeDyPhiDyPhi $\int_{\gamma_x} \partial_y \varphi_j(y,z)\partial_y\varphi_k(y,x) \,dydz$
\item ComputeDzPhiDzPhi
$\int_{\gamma_x} \partial_z \varphi_j(y,z)\partial_z\varphi_k(y,x) \,dydz$
\item ComputePhi
$\int_{\gamma_x} \varphi_k(y,x) \,dydz$
\end{itemize}

L'elemento principale di questa classe \'e ConstructModalBasis. In realt\'a tale metodo non \'e altro che un wrappers che facilita l'istanziamento della classe da parte dell'utente. Infatti dietro tale metodo si nasconde una chiamata alla factory dove sono schedati i possibili figli di ModalSpace.
 \textcolor{red}{Qua possiamo aggiungere il codice di ConstructModalBasis cos\'i si capisce cosa nascondiamo.}


\begin{lstlisting}
boost::shared_ptr <ModalSpace> ModalSpace::
ConstructModalBasis ( 	const Real & Ly,
 			const Real & Lz, 
 			const UInt & M, 
 			const std::string & down, 
 			const std::string & left, 
 			const std::string & up, 
 			const std::string & right )
{
	std::string bc = down + left + up + right;
	std::string id;

	if(bc == "dirdirdirdir")
	{
		id = "DDDD";
	}
	else if (bc == "robrobrobrob")
	{
		id = "RRRR"
	}
	else
	{
		ERROR_MSG ("This kind of bc has not been implemented yet, please add it!");
	}
}
\end{lstlisting} 
 \textcolor{blue}{Mi sono convinto che l'approccio ereditariet\'a \'e quello migliore, tuttavia dovremmo vedere il reale utilizzo che facciamo di questa factory}
 
\section{HiModAssembler}
 
 Sono momentaneamente separate ma \'e chiaro che devono appartenere alla stessa classe, ovvero a quella che sintetizzer\'a insieme Modalspace e FESpace 1D (ovvero quello costruito sulla fibra di supporto).
 
 \textcolor{red}{HiModView e HiModAssembler devono continuamente lavorare con gli elementi di Modalspace e FESpace 1D non sarebbe il caso di instaurare un legame pi\'u intimo?Magari specificando l'amicizia di HiMod con Modalspace e FESpace?Troppo incasinato?Si velocizza il tutto (non occorre infatti passare dai noiosi getters)?}
 
Gli unici membri di HiModAssembler e HiModView sono fespace e modalbasis (in HiModAssembler c'\'e anche etfespace ma direi che dobbiamo toglierlo e non farlo creare nel main, quella \'e sicuramente una questione interna di come abbiamo voluto implementare il calcolo dei coefficienti della matrice, inoltre aumentiamo in leggibilit\'a).

Ecco le uilit\'a di HiModAssembler:
\begin{itemize}
\item AddADRProblem
\item interpolate
\item Addrhs (costante e functionType)
\item Addrhsfunctor
\item AddDirichletBCIn (Momentanemente via penalizzazione)
\end{itemize}

Ecco invece le utilit\'a di HiModView:
\begin{itemize}
\item funCoeff3D (genera i valori nodali su una griglia partendo dal vettore soluzione o da una funzione)
\item normL2 (dato il vettore che sputa fuori funCoeff3D ne fa la normaL2)
\item ConvergeFile (crea un file di output gestibile tramite getpot, utilizzo limitato al testconvergence)
\end{itemize}


\section{Basis1dAbstract}

Le Educated Bases (E.B.) sono una scelta possibile da adottare nella risoluzione di un problema ADR con tecniche di riduzione gerarchica. Il concetto base si fonda sul teorema (citazione di Salsa) e sullipotesi di separabilit\`a delle variabili. Le E.B. vengono costruite "ad hoc" sulle condizioni di vaso del problema in oggetto. L'algoritmo che permette la generazione di queste basi \`e riassunto qui di seguito:

\begin{itemize}
\item[\textbf{1.}] \textbf{Costruzione di un problema ausiliario} che rispecchi la natura delle condizioni alle pareti del problema originale (devono essere omogenee) e passaggio ai relativi problemi agli autovalori.
\mybox{
Nel caso si abbiano condizioni di robin uguali sull'intera parete del vaso, dovremo considerare il seguente problema ausiliario:
\begin{equation}
\label{eq: problema RRRR}
\begin{cases}
-\Delta u(y,z)= 0 & \text{in $\gamma_x$}\\
\mu \nabla u(y,z) \cdot \vect{n}_{\gamma_x} +\chi u(y,z)=0 & \text{su $\Gamma_{vaso}$} \\
\end{cases}
\end{equation}
Si passi ora al problema agli autovalori associato al precedente sistema e ipotizzando la separazione di variabili per $u(y,z)=\varphi(y)\vartheta(z)$, si arrivano facilmente ad ottenere i seguenti sottoproblemi agli autovalori:
\begin{equation}
\label{eq: problema RR1}
\begin{cases}
-\varphi(y)'' = K_y\varphi(y) & \\
\mu \varphi(y)' +\chi \varphi(y) = 0 & \text{per $y=L_y$} \\
-\mu \varphi(y)'+\chi \varphi(y)=0 & \text{per $y=0$} \\
\end{cases}
\end{equation}
\begin{equation}
\label{eq: problema RR2}
\begin{cases}
-\vartheta(z)'' = K_z\vartheta(z) & \\
\mu \vartheta(z)' +\chi \vartheta(z) = 0 & \text{per $z=L_z$} \\
-\mu \vartheta(z)'+\chi \vartheta(z)=0 & \text{per $z=0$} \\
\end{cases}
\end{equation}
}{Esempio - RRRR}

\item[\textbf{2.}] \textbf{Identificazione del tipo di soluzione} dei problemi agli autovalori associati.

\mybox{
Per i sottoproblemi ottenuti i generi di soluzione sono i seguenti:
\begin{equation}
\label{eq: 1sottoproblema}
\begin{array}{c}
\varphi (y)=Asin(\sqrt{K_y}y)+Bcos(\sqrt{K_y}y) \\ \\
\vartheta (z)=Asin(\sqrt{K_z}z)+Bcos(\sqrt{K_z}z)
\end{array}
\end{equation}

}{Esempio - RRRR}

\item[\textbf{3.}] \textbf{Ricerca degli autovalori di un sottoproblema} tramite risoluzione dell'equazione non lineare associata ad esso, ottenuta risolvendo le condizioni di bordo.
\mybox{
Nel caso trattato in esempio le equazioni che si ottengono sono le seguenti ($x = \sqrt{K_y}$ e $w= \sqrt{K_z}$):
\begin{equation}
\label{eq: funzione autovalori}
\begin{array}{c}
f(x)= 2\mu x + tan(L_y x)\left(\chi - \frac{\mu ^2 x^2 }{\chi} \right) \\ \\
f(w)= 2\mu w + tan(L_z w)\left(\chi - \frac{\mu ^2 w^2 }{\chi} \right)
\end{array}
\end{equation}
}{Esempio - RRRR}
\end{itemize}

Come presentato in breve nel capitolo (Nozioni base), HiMod si basa sulla riduzione dei gradi di libert\'a del sistema discreto, questo risultato si ottiene ordinando le basi scelte in maniera gerarchica ed utilizzando quelle legate alle frequenze pi\'u basse. Dunque il primo passo \'e capire, dato un numero di modi massimo che si vuole dedicare per la componente trasversale, qual'\'e il set di basi modali da utilizzare.
\mybox{
Nel caso di condizioni al bordo di Dirichlet il problema si semplifica. Infatti non occorre adottare l'algoritmo mostrato precedentemente, gli autovalori che si ottengono sono noti a priori e sono della forma:
\begin{equation}
\label{eq: problema agli autovalori dirichlet}
\begin{array}{c l}
K_y = \big( \frac{\pi p}{L_y}\big)^2 & p = 1, ... ,m_y\\
K_z = \big( \frac{\pi q}{L_z}\big)^2 & q = 1, ... ,m_z\\
\end{array}
\end{equation}
Dunque \'e nota la relazione $\lambda(K_y,K_z)$ a priori e risulta molto semplice ordinare in modo crescente gli autovalori definendo quindi $m_y$ e $m_z$.
}{Osservazione}


\textcolor{red}{Possiamo discutere velocemente l'albero delle scelte (che poi sarebbe la funzione EigensProvider), che in realt\'a sar\'a utilizzato tale e quale per il caso generale delle educated basis, infatti se adesso il passaggio \'e semplicemente p = p +1, dopo il passaggio sar\'a p = Next().
La ricerca degli autovalori rallenter\'a parecchio dato che si dovr\'a risolvere un problema non lineare ogni volta che si vuole aggiornare un nodo.}

Esponiamo quindi lo pseudocodice che, dato il numero di modi da utilizzare, determina l'elenco delle frequenze e sotto frequenze:


\begin{lstlisting}
//Dichiarazione set di ritorno
M_Eigenvalues;
//Suggerisco di farlo un pair di pair visto che non possiamo fare la tupla, la prima pair sono i sotto autovalori, la seconda pair sono le coordinate (ovver p e q)

//Dichiarazione set degli scarti
scarti;

//Inserimento delle prime sottofrequenze e prima coordinata (1,1)
KzOld = M_EducatedBasisy->Next();
kyOld = M_educated->BasiszNext();
M_eigenvalues.insert(make_pair(KyOld,KzOld) );

//Inizializzazione set degli scarti
scarti.insert(make_pair(M_EducatedBasisy->Next(),KzOld));
scarti.insert(make_pair(KyOld,M_EducatedBasisz->Next()));

//Ciclo sul numero di modi scelto
for(UInt i=1;i\M_mtot;++i)
{
	//Prendo il primo elemento del vettore degli scarti, che sono ordinati per lambda=Ky+Kz dal più piccolo al più grande e lo inserisco nel set di uscita
	M_eigenvalues.insert(scarti.begin());

//Inoltre registro le coordinate del nodo preso e i valori dei sottoautovalori
i = prima coordinata;
j = seconda coordinata;
KzOld =  
KyOld =

//Mi occupo ora di branchare in maniera corretta e senza ricalcolare autovalori che già conosco
	if(!Check_presence(i+1,j))
		scarti.insert(Check_eigen(1,i+1),KzOld);

	if(!Check_presence(i,j+1))		
		scarti.insert(KyOld,Check_eigen(2,j+1));
}
\end{lstlisting}

